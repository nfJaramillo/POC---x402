{"version":3,"sources":["../../src/schemes/exact/index.ts","../../src/schemes/exact/evm/index.ts","../../src/schemes/exact/evm/facilitator.ts"],"sourcesContent":["export * as evm from \"./evm\";\r\n\r\nexport const SCHEME = \"exact\";\r\n","export * from \"./client\";\r\nexport * from \"./facilitator\";\r\nexport * from \"./utils/paymentUtils\";\r\n","import { Account, Address, Chain, Hex, Transport, verifyTypedData } from \"viem\";\r\nimport { getNetworkId } from \"../../../shared\";\r\nimport { getVersion, getERC20Balance } from \"../../../shared/evm\";\r\nimport {\r\n  usdcABI as abi,\r\n  authorizationTypes,\r\n  config,\r\n  ConnectedClient,\r\n  SignerWallet,\r\n} from \"../../../types/shared/evm\";\r\nimport {\r\n  PaymentPayload,\r\n  PaymentRequirements,\r\n  SettleResponse,\r\n  VerifyResponse,\r\n} from \"../../../types/verify\";\r\nimport { SCHEME } from \"../../exact\";\r\n\r\n/**\r\n * Verifies a payment payload against the required payment details\r\n *\r\n * This function performs several verification steps:\r\n * - Verifies protocol version compatibility\r\n * - Validates the permit signature\r\n * - Confirms USDC contract address is correct for the chain\r\n * - Checks permit deadline is sufficiently in the future\r\n * - Verifies client has sufficient USDC balance\r\n * - Ensures payment amount meets required minimum\r\n *\r\n * @param client - The public client used for blockchain interactions\r\n * @param payload - The signed payment payload containing transfer parameters and signature\r\n * @param paymentRequirements - The payment requirements that the payload must satisfy\r\n * @returns A ValidPaymentRequest indicating if the payment is valid and any invalidation reason\r\n */\r\nexport async function verify<\r\n  transport extends Transport,\r\n  chain extends Chain,\r\n  account extends Account | undefined,\r\n>(\r\n  client: ConnectedClient<transport, chain, account>,\r\n  payload: PaymentPayload,\r\n  paymentRequirements: PaymentRequirements,\r\n): Promise<VerifyResponse> {\r\n  /* TODO: work with security team on brainstorming more verification steps\r\n  verification steps:\r\n    - ✅ verify payload version\r\n    - ✅ verify usdc address is correct for the chain\r\n    - ✅ verify permit signature\r\n    - ✅ verify deadline\r\n    - verify nonce is current\r\n    - ✅ verify client has enough funds to cover paymentRequirements.maxAmountRequired\r\n    - ✅ verify value in payload is enough to cover paymentRequirements.maxAmountRequired\r\n    - check min amount is above some threshold we think is reasonable for covering gas\r\n    - verify resource is not already paid for (next version)\r\n    */\r\n\r\n  // Verify payload version\r\n  if (payload.scheme !== SCHEME || paymentRequirements.scheme !== SCHEME) {\r\n    return {\r\n      isValid: false,\r\n      invalidReason: `Incompatible payload scheme. payload: ${payload.scheme}, paymentRequirements: ${paymentRequirements.scheme}, supported: ${SCHEME}`,\r\n      payer: payload.payload.authorization.from,\r\n    };\r\n  }\r\n\r\n  let name: string;\r\n  let chainId: number;\r\n  let erc20Address: Address;\r\n  let version: string;\r\n  try {\r\n    chainId = getNetworkId(payload.network);\r\n    name = paymentRequirements.extra?.name ?? config[chainId.toString()].usdcName;\r\n    erc20Address = paymentRequirements.asset as Address;\r\n    version = paymentRequirements.extra?.version ?? (await getVersion(client));\r\n  } catch {\r\n    return {\r\n      isValid: false,\r\n      invalidReason: `invalid_network`,\r\n      payer: payload.payload.authorization.from,\r\n    };\r\n  }\r\n  // Verify permit signature is recoverable for the owner address\r\n  const permitTypedData = {\r\n    types: authorizationTypes,\r\n    primaryType: \"TransferWithAuthorization\" as const,\r\n    domain: {\r\n      name,\r\n      version,\r\n      chainId,\r\n      verifyingContract: erc20Address,\r\n    },\r\n    message: {\r\n      from: payload.payload.authorization.from,\r\n      to: payload.payload.authorization.to,\r\n      value: payload.payload.authorization.value,\r\n      validAfter: payload.payload.authorization.validAfter,\r\n      validBefore: payload.payload.authorization.validBefore,\r\n      nonce: payload.payload.authorization.nonce,\r\n    },\r\n  };\r\n  const recoveredAddress = await verifyTypedData({\r\n    address: payload.payload.authorization.from as Address,\r\n    ...permitTypedData,\r\n    signature: payload.payload.signature as Hex,\r\n  });\r\n  if (!recoveredAddress) {\r\n    return {\r\n      isValid: false,\r\n      invalidReason: \"invalid_scheme\", //\"Invalid permit signature\",\r\n      payer: payload.payload.authorization.from,\r\n    };\r\n  }\r\n\r\n  // Verify deadline is not yet expired\r\n  // Pad 3 block to account for round tripping\r\n  if (\r\n    BigInt(payload.payload.authorization.validBefore) < BigInt(Math.floor(Date.now() / 1000) + 6)\r\n  ) {\r\n    return {\r\n      isValid: false,\r\n      invalidReason: \"invalid_scheme\", //\"Deadline on permit isn't far enough in the future\",\r\n      payer: payload.payload.authorization.from,\r\n    };\r\n  }\r\n  // Verify deadline is not yet valid\r\n  if (BigInt(payload.payload.authorization.validAfter) > BigInt(Math.floor(Date.now() / 1000))) {\r\n    return {\r\n      isValid: false,\r\n      invalidReason: \"invalid_scheme\", //\"Deadline on permit is in the future\",\r\n      payer: payload.payload.authorization.from,\r\n    };\r\n  }\r\n  // Verify client has enough funds to cover paymentRequirements.maxAmountRequired\r\n  const balance = await getERC20Balance(\r\n    client,\r\n    erc20Address,\r\n    payload.payload.authorization.from as Address,\r\n  );\r\n  if (balance < BigInt(paymentRequirements.maxAmountRequired)) {\r\n    return {\r\n      isValid: false,\r\n      invalidReason: \"insufficient_funds\", //\"Client does not have enough funds\",\r\n      payer: payload.payload.authorization.from,\r\n    };\r\n  }\r\n  // Verify value in payload is enough to cover paymentRequirements.maxAmountRequired\r\n  if (BigInt(payload.payload.authorization.value) < BigInt(paymentRequirements.maxAmountRequired)) {\r\n    return {\r\n      isValid: false,\r\n      invalidReason: \"invalid_scheme\", //\"Value in payload is not enough to cover paymentRequirements.maxAmountRequired\",\r\n      payer: payload.payload.authorization.from,\r\n    };\r\n  }\r\n  return {\r\n    isValid: true,\r\n    invalidReason: undefined,\r\n    payer: payload.payload.authorization.from,\r\n  };\r\n}\r\n\r\n/**\r\n * Settles a payment by executing a USDC transferWithAuthorization transaction\r\n *\r\n * This function executes the actual USDC transfer using the signed authorization from the user.\r\n * The facilitator wallet submits the transaction but does not need to hold or transfer any tokens itself.\r\n *\r\n * @param wallet - The facilitator wallet that will submit the transaction\r\n * @param paymentPayload - The signed payment payload containing the transfer parameters and signature\r\n * @param paymentRequirements - The original payment details that were used to create the payload\r\n * @returns A PaymentExecutionResponse containing the transaction status and hash\r\n */\r\nexport async function settle<transport extends Transport, chain extends Chain>(\r\n  wallet: SignerWallet<chain, transport>,\r\n  paymentPayload: PaymentPayload,\r\n  paymentRequirements: PaymentRequirements,\r\n): Promise<SettleResponse> {\r\n  // re-verify to ensure the payment is still valid\r\n  const valid = await verify(wallet, paymentPayload, paymentRequirements);\r\n\r\n  if (!valid.isValid) {\r\n    return {\r\n      success: false,\r\n      network: paymentPayload.network,\r\n      transaction: \"\",\r\n      errorReason: \"invalid_scheme\", //`Payment is no longer valid: ${valid.invalidReason}`,\r\n      payer: paymentPayload.payload.authorization.from,\r\n    };\r\n  }\r\n\r\n  const tx = await wallet.writeContract({\r\n    address: paymentRequirements.asset as Address,\r\n    abi,\r\n    functionName: \"transferWithAuthorization\" as const,\r\n    args: [\r\n      paymentPayload.payload.authorization.from as Address,\r\n      paymentPayload.payload.authorization.to as Address,\r\n      BigInt(paymentPayload.payload.authorization.value),\r\n      BigInt(paymentPayload.payload.authorization.validAfter),\r\n      BigInt(paymentPayload.payload.authorization.validBefore),\r\n      paymentPayload.payload.authorization.nonce as Hex,\r\n      paymentPayload.payload.signature as Hex,\r\n    ],\r\n    chain: wallet.chain as Chain,\r\n  });\r\n\r\n  const receipt = await wallet.waitForTransactionReceipt({ hash: tx });\r\n\r\n  if (receipt.status !== \"success\") {\r\n    return {\r\n      success: false,\r\n      errorReason: \"invalid_scheme\", //`Transaction failed`,\r\n      transaction: tx,\r\n      network: paymentPayload.network,\r\n      payer: paymentPayload.payload.authorization.from,\r\n    };\r\n  }\r\n\r\n  return {\r\n    success: true,\r\n    transaction: tx,\r\n    network: paymentPayload.network,\r\n    payer: paymentPayload.payload.authorization.from,\r\n  };\r\n}\r\n"],"mappings":"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","names":[]}