{"version":3,"sources":["../../../src/verify/index.ts","../../../src/verify/useFacilitator.ts","../../../src/shared/json.ts","../../../src/types/shared/evm/wallet.ts","../../../src/schemes/exact/evm/sign.ts","../../../src/types/verify/x402Specs.ts","../../../src/types/shared/money.ts","../../../src/types/shared/network.ts","../../../src/types/verify/facilitator.ts","../../../src/shared/cdp.ts"],"sourcesContent":["export * from \"./useFacilitator\";\r\n","import axios from \"axios\";\r\nimport { toJsonSafe } from \"../shared\";\r\nimport { FacilitatorConfig } from \"../types\";\r\nimport {\r\n  PaymentPayload,\r\n  PaymentRequirements,\r\n  SettleResponse,\r\n  VerifyResponse,\r\n} from \"../types/verify\";\r\n\r\nconst DEFAULT_FACILITATOR_URL = \"https://x402.org/facilitator\";\r\n\r\nexport type CreateHeaders = () => Promise<{\r\n  verify: Record<string, string>;\r\n  settle: Record<string, string>;\r\n}>;\r\n\r\n/**\r\n * Creates a facilitator client for interacting with the X402 payment facilitator service\r\n *\r\n * @param facilitator - The facilitator config to use. If not provided, the default facilitator will be used.\r\n * @returns An object containing verify and settle functions for interacting with the facilitator\r\n */\r\nexport function useFacilitator(facilitator?: FacilitatorConfig) {\r\n  /**\r\n   * Verifies a payment payload with the facilitator service\r\n   *\r\n   * @param payload - The payment payload to verify\r\n   * @param paymentRequirements - The payment requirements to verify against\r\n   * @returns A promise that resolves to the verification response\r\n   */\r\n  async function verify(\r\n    payload: PaymentPayload,\r\n    paymentRequirements: PaymentRequirements,\r\n  ): Promise<VerifyResponse> {\r\n    const url = facilitator?.url || DEFAULT_FACILITATOR_URL;\r\n\r\n    const res = await axios.post(\r\n      `${url}/verify`,\r\n      {\r\n        x402Version: payload.x402Version,\r\n        paymentPayload: toJsonSafe(payload),\r\n        paymentRequirements: toJsonSafe(paymentRequirements),\r\n      },\r\n      {\r\n        headers: facilitator?.createAuthHeaders\r\n          ? (await facilitator.createAuthHeaders()).verify\r\n          : undefined,\r\n      },\r\n    );\r\n\r\n    if (res.status !== 200) {\r\n      throw new Error(`Failed to verify payment: ${res.statusText}`);\r\n    }\r\n\r\n    return res.data as VerifyResponse;\r\n  }\r\n\r\n  /**\r\n   * Settles a payment with the facilitator service\r\n   *\r\n   * @param payload - The payment payload to settle\r\n   * @param paymentRequirements - The payment requirements for the settlement\r\n   * @returns A promise that resolves to the settlement response\r\n   */\r\n  async function settle(\r\n    payload: PaymentPayload,\r\n    paymentRequirements: PaymentRequirements,\r\n  ): Promise<SettleResponse> {\r\n    const url = facilitator?.url || DEFAULT_FACILITATOR_URL;\r\n\r\n    const res = await axios.post(\r\n      `${url}/settle`,\r\n      {\r\n        x402Version: payload.x402Version,\r\n        paymentPayload: toJsonSafe(payload),\r\n        paymentRequirements: toJsonSafe(paymentRequirements),\r\n      },\r\n      {\r\n        headers: facilitator?.createAuthHeaders\r\n          ? (await facilitator.createAuthHeaders()).settle\r\n          : undefined,\r\n      },\r\n    );\r\n\r\n    if (res.status !== 200) {\r\n      throw new Error(`Failed to settle payment: ${res.statusText}`);\r\n    }\r\n\r\n    return res.data as SettleResponse;\r\n  }\r\n\r\n  return { verify, settle };\r\n}\r\n\r\nexport const { verify, settle } = useFacilitator();\r\n","/**\r\n * Converts an object to a JSON-safe format by converting bigint values to strings\r\n * and recursively processing nested objects and arrays\r\n *\r\n * @param data - The object to convert to JSON-safe format\r\n * @returns A new object with all bigint values converted to strings\r\n */\r\nexport function toJsonSafe<T extends object>(data: T): object {\r\n  if (typeof data !== \"object\") {\r\n    throw new Error(\"Data is not an object\");\r\n  }\r\n\r\n  /**\r\n   * Recursively converts values to JSON-safe format\r\n   *\r\n   * @param value - The value to convert\r\n   * @returns The converted value with bigints as strings\r\n   */\r\n  function convert(value: unknown): unknown {\r\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\r\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\r\n    }\r\n\r\n    if (Array.isArray(value)) {\r\n      return value.map(convert);\r\n    }\r\n\r\n    if (typeof value === \"bigint\") {\r\n      return value.toString();\r\n    }\r\n    return value;\r\n  }\r\n\r\n  return convert(data) as object;\r\n}\r\n","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\r\nimport type {\r\n  Chain,\r\n  Transport,\r\n  Client,\r\n  Account,\r\n  RpcSchema,\r\n  PublicActions,\r\n  WalletActions,\r\n  PublicClient,\r\n} from \"viem\";\r\nimport { baseSepolia } from \"viem/chains\";\r\nimport { privateKeyToAccount } from \"viem/accounts\";\r\nimport { Hex } from \"viem\";\r\n\r\n// Create a public client for reading data\r\nexport type SignerWallet<\r\n  chain extends Chain = Chain,\r\n  transport extends Transport = Transport,\r\n  account extends Account = Account,\r\n> = Client<\r\n  transport,\r\n  chain,\r\n  account,\r\n  RpcSchema,\r\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\r\n>;\r\n\r\nexport type ConnectedClient<\r\n  transport extends Transport = Transport,\r\n  chain extends Chain | undefined = Chain,\r\n  account extends Account | undefined = undefined,\r\n> = PublicClient<transport, chain, account>;\r\n\r\n/**\r\n * Creates a public client configured for the Base Sepolia testnet\r\n *\r\n * @returns A public client instance connected to Base Sepolia\r\n */\r\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\r\n  return createPublicClient({\r\n    chain: baseSepolia,\r\n    transport: http(),\r\n  }).extend(publicActions);\r\n}\r\n\r\n/**\r\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\r\n *\r\n * @param privateKey - The private key to use for signing transactions\r\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\r\n */\r\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\r\n  return createWalletClient({\r\n    chain: baseSepolia,\r\n    transport: http(),\r\n    account: privateKeyToAccount(privateKey),\r\n  }).extend(publicActions);\r\n}\r\n\r\n/**\r\n * Checks if a wallet is a signer wallet\r\n *\r\n * @param wallet - The wallet to check\r\n * @returns True if the wallet is a signer wallet, false otherwise\r\n */\r\nexport function isSignerWallet<\r\n  TChain extends Chain = Chain,\r\n  TTransport extends Transport = Transport,\r\n  TAccount extends Account = Account,\r\n>(\r\n  wallet: SignerWallet<TChain, TTransport, TAccount> | Account,\r\n): wallet is SignerWallet<TChain, TTransport, TAccount> {\r\n  return \"chain\" in wallet && \"transport\" in wallet;\r\n}\r\n\r\n/**\r\n * Checks if a wallet is an account\r\n *\r\n * @param wallet - The wallet to check\r\n * @returns True if the wallet is an account, false otherwise\r\n */\r\nexport function isAccount(wallet: SignerWallet | Account): wallet is Account {\r\n  return \"address\" in wallet && \"type\" in wallet;\r\n}\r\n","import { getRandomValues } from \"crypto\";\r\nimport { Account, Address, Chain, Hex, toHex, Transport } from \"viem\";\r\nimport { getNetworkId } from \"../../../shared\";\r\nimport {\r\n  authorizationTypes,\r\n  isAccount,\r\n  isSignerWallet,\r\n  SignerWallet,\r\n} from \"../../../types/shared/evm\";\r\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\r\n\r\n/**\r\n * Signs an EIP-3009 authorization for USDC transfer\r\n *\r\n * @param walletClient - The wallet client that will sign the authorization\r\n * @param params - The authorization parameters containing transfer details\r\n * @param params.from - The address tokens will be transferred from\r\n * @param params.to - The address tokens will be transferred to\r\n * @param params.value - The amount of USDC tokens to transfer (in base units)\r\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\r\n * @param params.validBefore - Unix timestamp before which the authorization is valid\r\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\r\n * @param paymentRequirements - The payment requirements containing asset and network information\r\n * @param paymentRequirements.asset - The address of the USDC contract\r\n * @param paymentRequirements.network - The network where the USDC contract exists\r\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\r\n * @returns The signature for the authorization\r\n */\r\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\r\n  walletClient: SignerWallet<chain, transport> | Account,\r\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\r\n  { asset, network, extra }: PaymentRequirements,\r\n): Promise<{ signature: Hex }> {\r\n  const chainId = getNetworkId(network);\r\n  const name = extra?.name;\r\n  const version = extra?.version;\r\n  const account = isSignerWallet(walletClient) ? walletClient.account : walletClient;\r\n\r\n  const data = {\r\n    account,\r\n    types: authorizationTypes,\r\n    domain: {\r\n      name,\r\n      version,\r\n      chainId,\r\n      verifyingContract: asset as Address,\r\n    },\r\n    primaryType: \"TransferWithAuthorization\" as const,\r\n    message: {\r\n      from,\r\n      to,\r\n      value,\r\n      validAfter,\r\n      validBefore,\r\n      nonce: nonce,\r\n    },\r\n  };\r\n\r\n  if (isSignerWallet(walletClient)) {\r\n    const signature = await walletClient.signTypedData(data);\r\n    return {\r\n      signature,\r\n    };\r\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\r\n    const signature = await walletClient.signTypedData(data);\r\n    return {\r\n      signature,\r\n    };\r\n  } else {\r\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a random 32-byte nonce for use in authorization signatures\r\n *\r\n * @returns A random 32-byte nonce as a hex string\r\n */\r\nexport function createNonce(): Hex {\r\n  return toHex(getRandomValues(new Uint8Array(32)));\r\n}\r\n","import { z } from \"zod\";\r\nimport { NetworkSchema } from \"../shared\";\r\n// Constants\r\nconst EvmMaxAtomicUnits = 18;\r\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\r\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\r\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\r\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]{130}$/;\r\n// Enums\r\nexport const schemes = [\"exact\"] as const;\r\nexport const x402Versions = [1] as const;\r\nexport const ErrorReasons = [\"insufficient_funds\", \"invalid_scheme\", \"invalid_network\"] as const;\r\n// Refiners\r\nconst isInteger = (value: string) => Number.isInteger(Number(value)) && Number(value) >= 0;\r\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\r\n\r\n// x402PaymentRequirements\r\nexport const PaymentRequirementsSchema = z.object({\r\n  scheme: z.enum(schemes),\r\n  network: NetworkSchema,\r\n  maxAmountRequired: z.string().refine(isInteger),\r\n  resource: z.string().url(),\r\n  description: z.string(),\r\n  mimeType: z.string(),\r\n  outputSchema: z.record(z.any()).optional(),\r\n  payTo: z.string().regex(MixedAddressRegex),\r\n  maxTimeoutSeconds: z.number().int(),\r\n  asset: z.string().regex(MixedAddressRegex),\r\n  extra: z.record(z.any()).optional(),\r\n});\r\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\r\n\r\n// x402ExactEvmPayload\r\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\r\n  from: z.string().regex(EvmAddressRegex),\r\n  to: z.string().regex(EvmAddressRegex),\r\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\r\n  validAfter: z.string().refine(isInteger),\r\n  validBefore: z.string().refine(isInteger),\r\n  nonce: z.string().regex(HexEncoded64ByteRegex),\r\n});\r\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\r\n\r\nexport const ExactEvmPayloadSchema = z.object({\r\n  signature: z.string().regex(EvmSignatureRegex),\r\n  authorization: ExactEvmPayloadAuthorizationSchema,\r\n});\r\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\r\n\r\n// x402PaymentPayload\r\nexport const PaymentPayloadSchema = z.object({\r\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\r\n  scheme: z.enum(schemes),\r\n  network: NetworkSchema,\r\n  payload: ExactEvmPayloadSchema,\r\n});\r\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\r\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\r\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\r\n};\r\n\r\n// x402VerifyResponse\r\nexport const VerifyResponseSchema = z.object({\r\n  isValid: z.boolean(),\r\n  invalidReason: z.enum(ErrorReasons).optional(),\r\n  payer: z.string().regex(MixedAddressRegex).optional(),\r\n});\r\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\r\n\r\n// x402SettleResponse\r\nexport const SettleResponseSchema = z.object({\r\n  success: z.boolean(),\r\n  errorReason: z.enum(ErrorReasons).optional(),\r\n  payer: z.string().regex(MixedAddressRegex).optional(),\r\n  transaction: z.string().regex(MixedAddressRegex),\r\n  network: NetworkSchema,\r\n});\r\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\r\n\r\n// x402SupportedPaymentKind\r\nexport const SupportedPaymentKindSchema = z.object({\r\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\r\n  scheme: z.enum(schemes),\r\n  network: NetworkSchema,\r\n});\r\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\r\n\r\n// x402SupportedPaymentKindsResponse\r\nexport const SupportedPaymentKindsResponseSchema = z.object({\r\n  kinds: z.array(SupportedPaymentKindSchema),\r\n});\r\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\r\n","import { z } from \"zod\";\r\n\r\nexport const moneySchema = z\r\n  .union([z.string().transform(x => x.replace(/[^0-9.-]+/g, \"\")), z.number()])\r\n  .pipe(z.coerce.number().min(0.0001).max(999999999));\r\n\r\nexport type Money = z.input<typeof moneySchema>;\r\n","import { z } from \"zod\";\r\n\r\nexport const NetworkSchema = z.enum([\"base-sepolia\", \"base\"]);\r\nexport type Network = z.infer<typeof NetworkSchema>;\r\n\r\nexport const SupportedEVMNetworks: Network[] = [\"base-sepolia\", \"base\"];\r\nexport const EvmNetworkToChainId = new Map<Network, number>([\r\n  [\"base-sepolia\", 84532],\r\n  [\"base\", 8453],\r\n]);\r\n\r\nexport const ChainIdToNetwork = Object.fromEntries(\r\n  SupportedEVMNetworks.map(network => [EvmNetworkToChainId.get(network), network]),\r\n) as Record<number, Network>;\r\n","import { z } from \"zod\";\r\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\r\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\r\n\r\nexport const facilitatorRequestSchema = z.object({\r\n  paymentHeader: z.string(),\r\n  paymentRequirements: PaymentRequirementsSchema,\r\n});\r\n\r\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\r\n\r\n/**\r\n * Encodes a settlement response into a base64 header string\r\n *\r\n * @param response - The settlement response to encode\r\n * @returns A base64 encoded string containing the settlement response\r\n */\r\nexport function settleResponseHeader(response: SettleResponse): string {\r\n  return safeBase64Encode(JSON.stringify(response));\r\n}\r\n\r\n/**\r\n * Decodes a base64 header string back into a settlement response\r\n *\r\n * @param header - The base64 encoded settlement response header\r\n * @returns The decoded settlement response object\r\n */\r\nexport function settleResponseFromHeader(header: string): SettleResponse {\r\n  const decoded = safeBase64Decode(header);\r\n  return JSON.parse(decoded) as SettleResponse;\r\n}\r\n","import { generateJwt } from \"@coinbase/cdp-sdk/auth\";\r\nimport { version } from \"../version\";\r\n\r\nconst SDK_VERSION = \"1.1.1\";\r\n\r\n/**\r\n * Creates an authorization header for a request to the Coinbase API.\r\n *\r\n * @param apiKeyId - The api key ID\r\n * @param apiKeySecret - The api key secret\r\n * @param requestHost - The host for the request (e.g. 'https://x402.org/facilitator')\r\n * @param requestPath - The path for the request (e.g. '/verify')\r\n * @returns The authorization header string\r\n */\r\nexport async function createAuthHeader(\r\n  apiKeyId: string,\r\n  apiKeySecret: string,\r\n  requestHost: string,\r\n  requestPath: string,\r\n) {\r\n  const jwt = await generateJwt({\r\n    apiKeyId,\r\n    apiKeySecret,\r\n    requestMethod: \"POST\",\r\n    requestHost,\r\n    requestPath,\r\n  });\r\n  return `Bearer ${jwt}`;\r\n}\r\n\r\n/**\r\n * Creates a correlation header for a request to the Coinbase API.\r\n *\r\n * @returns The correlation header string\r\n */\r\nexport function createCorrelationHeader(): string {\r\n  const data: Record<string, string> = {\r\n    sdk_version: SDK_VERSION,\r\n    sdk_language: \"typescript\",\r\n    source: \"x402\",\r\n    source_version: version,\r\n  };\r\n  return Object.keys(data)\r\n    .map(key => `${key}=${encodeURIComponent(data[key])}`)\r\n    .join(\",\");\r\n}\r\n"],"mappings":"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","names":["import_viem","import_zod","import_zod","import_zod","verify","axios","settle"]}