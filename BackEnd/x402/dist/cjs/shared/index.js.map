{"version":3,"sources":["../../../src/shared/index.ts","../../../src/shared/json.ts","../../../src/types/shared/evm/config.ts","../../../src/types/shared/evm/wallet.ts","../../../src/schemes/exact/evm/sign.ts","../../../src/types/verify/x402Specs.ts","../../../src/types/shared/money.ts","../../../src/types/shared/network.ts","../../../src/types/verify/facilitator.ts","../../../src/shared/evm/usdc.ts","../../../src/shared/network.ts","../../../src/client/selectPaymentRequirements.ts","../../../src/shared/paywall.ts","../../../src/shared/base64.ts","../../../src/shared/cdp.ts","../../../src/version.ts","../../../src/shared/middleware.ts"],"sourcesContent":["export * from \"./json\";\r\nexport * from \"./paywall\";\r\nexport * from \"./base64\";\r\nexport * from \"./network\";\r\nexport * from \"./cdp\";\r\nexport * from \"./middleware\";\r\n","/**\r\n * Converts an object to a JSON-safe format by converting bigint values to strings\r\n * and recursively processing nested objects and arrays\r\n *\r\n * @param data - The object to convert to JSON-safe format\r\n * @returns A new object with all bigint values converted to strings\r\n */\r\nexport function toJsonSafe<T extends object>(data: T): object {\r\n  if (typeof data !== \"object\") {\r\n    throw new Error(\"Data is not an object\");\r\n  }\r\n\r\n  /**\r\n   * Recursively converts values to JSON-safe format\r\n   *\r\n   * @param value - The value to convert\r\n   * @returns The converted value with bigints as strings\r\n   */\r\n  function convert(value: unknown): unknown {\r\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\r\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\r\n    }\r\n\r\n    if (Array.isArray(value)) {\r\n      return value.map(convert);\r\n    }\r\n\r\n    if (typeof value === \"bigint\") {\r\n      return value.toString();\r\n    }\r\n    return value;\r\n  }\r\n\r\n  return convert(data) as object;\r\n}\r\n","import { Address } from \"viem\";\r\n\r\nexport const config: Record<string, ChainConfig> = {\r\n  \"84532\": {\r\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\r\n    usdcName: \"USDC\",\r\n  },\r\n  \"8453\": {\r\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\r\n    usdcName: \"USDC\",\r\n  },\r\n};\r\n\r\nexport type ChainConfig = {\r\n  usdcAddress: Address;\r\n  usdcName: string;\r\n};\r\n","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\r\nimport type {\r\n  Chain,\r\n  Transport,\r\n  Client,\r\n  Account,\r\n  RpcSchema,\r\n  PublicActions,\r\n  WalletActions,\r\n  PublicClient,\r\n} from \"viem\";\r\nimport { baseSepolia } from \"viem/chains\";\r\nimport { privateKeyToAccount } from \"viem/accounts\";\r\nimport { Hex } from \"viem\";\r\n\r\n// Create a public client for reading data\r\nexport type SignerWallet<\r\n  chain extends Chain = Chain,\r\n  transport extends Transport = Transport,\r\n  account extends Account = Account,\r\n> = Client<\r\n  transport,\r\n  chain,\r\n  account,\r\n  RpcSchema,\r\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\r\n>;\r\n\r\nexport type ConnectedClient<\r\n  transport extends Transport = Transport,\r\n  chain extends Chain | undefined = Chain,\r\n  account extends Account | undefined = undefined,\r\n> = PublicClient<transport, chain, account>;\r\n\r\n/**\r\n * Creates a public client configured for the Base Sepolia testnet\r\n *\r\n * @returns A public client instance connected to Base Sepolia\r\n */\r\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\r\n  return createPublicClient({\r\n    chain: baseSepolia,\r\n    transport: http(),\r\n  }).extend(publicActions);\r\n}\r\n\r\n/**\r\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\r\n *\r\n * @param privateKey - The private key to use for signing transactions\r\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\r\n */\r\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\r\n  return createWalletClient({\r\n    chain: baseSepolia,\r\n    transport: http(),\r\n    account: privateKeyToAccount(privateKey),\r\n  }).extend(publicActions);\r\n}\r\n\r\n/**\r\n * Checks if a wallet is a signer wallet\r\n *\r\n * @param wallet - The wallet to check\r\n * @returns True if the wallet is a signer wallet, false otherwise\r\n */\r\nexport function isSignerWallet<\r\n  TChain extends Chain = Chain,\r\n  TTransport extends Transport = Transport,\r\n  TAccount extends Account = Account,\r\n>(\r\n  wallet: SignerWallet<TChain, TTransport, TAccount> | Account,\r\n): wallet is SignerWallet<TChain, TTransport, TAccount> {\r\n  return \"chain\" in wallet && \"transport\" in wallet;\r\n}\r\n\r\n/**\r\n * Checks if a wallet is an account\r\n *\r\n * @param wallet - The wallet to check\r\n * @returns True if the wallet is an account, false otherwise\r\n */\r\nexport function isAccount(wallet: SignerWallet | Account): wallet is Account {\r\n  return \"address\" in wallet && \"type\" in wallet;\r\n}\r\n","import { getRandomValues } from \"crypto\";\r\nimport { Account, Address, Chain, Hex, toHex, Transport } from \"viem\";\r\nimport { getNetworkId } from \"../../../shared\";\r\nimport {\r\n  authorizationTypes,\r\n  isAccount,\r\n  isSignerWallet,\r\n  SignerWallet,\r\n} from \"../../../types/shared/evm\";\r\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\r\n\r\n/**\r\n * Signs an EIP-3009 authorization for USDC transfer\r\n *\r\n * @param walletClient - The wallet client that will sign the authorization\r\n * @param params - The authorization parameters containing transfer details\r\n * @param params.from - The address tokens will be transferred from\r\n * @param params.to - The address tokens will be transferred to\r\n * @param params.value - The amount of USDC tokens to transfer (in base units)\r\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\r\n * @param params.validBefore - Unix timestamp before which the authorization is valid\r\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\r\n * @param paymentRequirements - The payment requirements containing asset and network information\r\n * @param paymentRequirements.asset - The address of the USDC contract\r\n * @param paymentRequirements.network - The network where the USDC contract exists\r\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\r\n * @returns The signature for the authorization\r\n */\r\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\r\n  walletClient: SignerWallet<chain, transport> | Account,\r\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\r\n  { asset, network, extra }: PaymentRequirements,\r\n): Promise<{ signature: Hex }> {\r\n  const chainId = getNetworkId(network);\r\n  const name = extra?.name;\r\n  const version = extra?.version;\r\n  const account = isSignerWallet(walletClient) ? walletClient.account : walletClient;\r\n\r\n  const data = {\r\n    account,\r\n    types: authorizationTypes,\r\n    domain: {\r\n      name,\r\n      version,\r\n      chainId,\r\n      verifyingContract: asset as Address,\r\n    },\r\n    primaryType: \"TransferWithAuthorization\" as const,\r\n    message: {\r\n      from,\r\n      to,\r\n      value,\r\n      validAfter,\r\n      validBefore,\r\n      nonce: nonce,\r\n    },\r\n  };\r\n\r\n  if (isSignerWallet(walletClient)) {\r\n    const signature = await walletClient.signTypedData(data);\r\n    return {\r\n      signature,\r\n    };\r\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\r\n    const signature = await walletClient.signTypedData(data);\r\n    return {\r\n      signature,\r\n    };\r\n  } else {\r\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a random 32-byte nonce for use in authorization signatures\r\n *\r\n * @returns A random 32-byte nonce as a hex string\r\n */\r\nexport function createNonce(): Hex {\r\n  return toHex(getRandomValues(new Uint8Array(32)));\r\n}\r\n","import { z } from \"zod\";\r\nimport { NetworkSchema } from \"../shared\";\r\n// Constants\r\nconst EvmMaxAtomicUnits = 18;\r\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\r\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\r\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\r\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]{130}$/;\r\n// Enums\r\nexport const schemes = [\"exact\"] as const;\r\nexport const x402Versions = [1] as const;\r\nexport const ErrorReasons = [\"insufficient_funds\", \"invalid_scheme\", \"invalid_network\"] as const;\r\n// Refiners\r\nconst isInteger = (value: string) => Number.isInteger(Number(value)) && Number(value) >= 0;\r\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\r\n\r\n// x402PaymentRequirements\r\nexport const PaymentRequirementsSchema = z.object({\r\n  scheme: z.enum(schemes),\r\n  network: NetworkSchema,\r\n  maxAmountRequired: z.string().refine(isInteger),\r\n  resource: z.string().url(),\r\n  description: z.string(),\r\n  mimeType: z.string(),\r\n  outputSchema: z.record(z.any()).optional(),\r\n  payTo: z.string().regex(MixedAddressRegex),\r\n  maxTimeoutSeconds: z.number().int(),\r\n  asset: z.string().regex(MixedAddressRegex),\r\n  extra: z.record(z.any()).optional(),\r\n});\r\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\r\n\r\n// x402ExactEvmPayload\r\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\r\n  from: z.string().regex(EvmAddressRegex),\r\n  to: z.string().regex(EvmAddressRegex),\r\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\r\n  validAfter: z.string().refine(isInteger),\r\n  validBefore: z.string().refine(isInteger),\r\n  nonce: z.string().regex(HexEncoded64ByteRegex),\r\n});\r\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\r\n\r\nexport const ExactEvmPayloadSchema = z.object({\r\n  signature: z.string().regex(EvmSignatureRegex),\r\n  authorization: ExactEvmPayloadAuthorizationSchema,\r\n});\r\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\r\n\r\n// x402PaymentPayload\r\nexport const PaymentPayloadSchema = z.object({\r\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\r\n  scheme: z.enum(schemes),\r\n  network: NetworkSchema,\r\n  payload: ExactEvmPayloadSchema,\r\n});\r\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\r\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\r\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\r\n};\r\n\r\n// x402VerifyResponse\r\nexport const VerifyResponseSchema = z.object({\r\n  isValid: z.boolean(),\r\n  invalidReason: z.enum(ErrorReasons).optional(),\r\n  payer: z.string().regex(MixedAddressRegex).optional(),\r\n});\r\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\r\n\r\n// x402SettleResponse\r\nexport const SettleResponseSchema = z.object({\r\n  success: z.boolean(),\r\n  errorReason: z.enum(ErrorReasons).optional(),\r\n  payer: z.string().regex(MixedAddressRegex).optional(),\r\n  transaction: z.string().regex(MixedAddressRegex),\r\n  network: NetworkSchema,\r\n});\r\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\r\n\r\n// x402SupportedPaymentKind\r\nexport const SupportedPaymentKindSchema = z.object({\r\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\r\n  scheme: z.enum(schemes),\r\n  network: NetworkSchema,\r\n});\r\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\r\n\r\n// x402SupportedPaymentKindsResponse\r\nexport const SupportedPaymentKindsResponseSchema = z.object({\r\n  kinds: z.array(SupportedPaymentKindSchema),\r\n});\r\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\r\n","import { z } from \"zod\";\r\n\r\nexport const moneySchema = z\r\n  .union([z.string().transform(x => x.replace(/[^0-9.-]+/g, \"\")), z.number()])\r\n  .pipe(z.coerce.number().min(0.0001).max(999999999));\r\n\r\nexport type Money = z.input<typeof moneySchema>;\r\n","import { z } from \"zod\";\r\n\r\nexport const NetworkSchema = z.enum([\"base-sepolia\", \"base\"]);\r\nexport type Network = z.infer<typeof NetworkSchema>;\r\n\r\nexport const SupportedEVMNetworks: Network[] = [\"base-sepolia\", \"base\"];\r\nexport const EvmNetworkToChainId = new Map<Network, number>([\r\n  [\"base-sepolia\", 84532],\r\n  [\"base\", 8453],\r\n]);\r\n\r\nexport const ChainIdToNetwork = Object.fromEntries(\r\n  SupportedEVMNetworks.map(network => [EvmNetworkToChainId.get(network), network]),\r\n) as Record<number, Network>;\r\n","import { z } from \"zod\";\r\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\r\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\r\n\r\nexport const facilitatorRequestSchema = z.object({\r\n  paymentHeader: z.string(),\r\n  paymentRequirements: PaymentRequirementsSchema,\r\n});\r\n\r\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\r\n\r\n/**\r\n * Encodes a settlement response into a base64 header string\r\n *\r\n * @param response - The settlement response to encode\r\n * @returns A base64 encoded string containing the settlement response\r\n */\r\nexport function settleResponseHeader(response: SettleResponse): string {\r\n  return safeBase64Encode(JSON.stringify(response));\r\n}\r\n\r\n/**\r\n * Decodes a base64 header string back into a settlement response\r\n *\r\n * @param header - The base64 encoded settlement response header\r\n * @returns The decoded settlement response object\r\n */\r\nexport function settleResponseFromHeader(header: string): SettleResponse {\r\n  const decoded = safeBase64Decode(header);\r\n  return JSON.parse(decoded) as SettleResponse;\r\n}\r\n","import { Account, Address, Chain, Client, Transport } from \"viem\";\r\nimport { config } from \"../../types/shared/evm/config\";\r\nimport { usdcABI as abi } from \"../../types/shared/evm/erc20PermitABI\";\r\nimport { ConnectedClient } from \"../../types/shared/evm/wallet\";\r\n\r\n/**\r\n * Gets the USDC contract address for the current chain from the client\r\n *\r\n * @param client - The Viem client instance connected to the blockchain\r\n * @returns The USDC contract address for the current chain\r\n */\r\nexport function getUsdcAddress<\r\n  transport extends Transport,\r\n  chain extends Chain | undefined = undefined,\r\n  account extends Account | undefined = undefined,\r\n>(client: Client<transport, chain, account>): Address {\r\n  return config[client.chain!.id.toString()].usdcAddress as Address;\r\n}\r\n\r\n/**\r\n * Gets the USDC contract address for a specific chain ID\r\n *\r\n * @param chainId - The chain ID to get the USDC contract address for\r\n * @returns The USDC contract address for the specified chain\r\n */\r\nexport function getUsdcAddressForChain(chainId: number): Address {\r\n  return config[chainId.toString()].usdcAddress as Address;\r\n}\r\n\r\n// Cache for storing the version value\r\nlet versionCache: string | null = null;\r\n\r\n/**\r\n * Gets the version of the USDC contract, using a cache to avoid repeated calls\r\n *\r\n * @param client - The Viem client instance connected to the blockchain\r\n * @returns A promise that resolves to the USDC contract version string\r\n */\r\nexport async function getVersion<\r\n  transport extends Transport,\r\n  chain extends Chain,\r\n  account extends Account | undefined = undefined,\r\n>(client: ConnectedClient<transport, chain, account>): Promise<string> {\r\n  // Return cached version if available\r\n  if (versionCache !== null) {\r\n    return versionCache;\r\n  }\r\n\r\n  // Fetch and cache version if not available\r\n  const version = await client.readContract({\r\n    address: getUsdcAddress(client),\r\n    abi,\r\n    functionName: \"version\",\r\n  });\r\n  versionCache = version as string;\r\n  return versionCache;\r\n}\r\n\r\n/**\r\n * Gets the USDC balance for a specific address\r\n *\r\n * @param client - The Viem client instance connected to the blockchain\r\n * @param address - The address to check the USDC balance for\r\n * @returns A promise that resolves to the USDC balance as a bigint\r\n */\r\nexport async function getUSDCBalance<\r\n  transport extends Transport,\r\n  chain extends Chain,\r\n  account extends Account | undefined = undefined,\r\n>(client: ConnectedClient<transport, chain, account>, address: Address): Promise<bigint> {\r\n  const balance = await client.readContract({\r\n    address: getUsdcAddressForChain(client.chain!.id),\r\n    abi,\r\n    functionName: \"balanceOf\",\r\n    args: [address],\r\n  });\r\n  return balance as bigint;\r\n}\r\n","import { EvmNetworkToChainId, Network } from \"../types/shared\";\r\n\r\n/**\r\n * Converts a network name to its corresponding chain ID\r\n *\r\n * @param network - The network name to convert to a chain ID\r\n * @returns The chain ID for the specified network\r\n * @throws Error if the network is not supported\r\n */\r\nexport function getNetworkId(network: Network): number {\r\n  if (EvmNetworkToChainId.has(network)) {\r\n    return EvmNetworkToChainId.get(network)!;\r\n  }\r\n  // TODO: Solana\r\n  throw new Error(`Unsupported network: ${network}`);\r\n}\r\n","import { Network, PaymentRequirements } from \"../types\";\r\nimport { getUsdcAddressForChain } from \"../shared/evm\";\r\nimport { getNetworkId } from \"../shared/network\";\r\n\r\n/**\r\n * Default selector for payment requirements.\r\n * Default behavior is to select the first payment requirement that has a USDC asset.\r\n * If no USDC payment requirement is found, the first payment requirement is selected.\r\n * \r\n * @param paymentRequirements - The payment requirements to select from.\r\n * @param network - The network to check against. If not provided, the network will not be checked.\r\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\r\n * @returns The payment requirement that is the most appropriate for the user.\r\n */\r\nexport function selectPaymentRequirements(paymentRequirements: PaymentRequirements[], network?: Network, scheme?: \"exact\"): PaymentRequirements {\r\n  // Sort `base` payment requirements to the front of the list. This is to ensure that base is preferred if available.\r\n  paymentRequirements.sort((a, b) => {\r\n    if (a.network === \"base\" && b.network !== \"base\") {\r\n      return -1;\r\n    }\r\n    if (a.network !== \"base\" && b.network === \"base\") {\r\n      return 1;\r\n    }\r\n    return 0;\r\n  });\r\n\r\n  // Filter down to the scheme/network if provided\r\n  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter(requirement => {\r\n    // If the scheme is not provided, we accept any scheme.\r\n    const isExpectedScheme = !scheme || requirement.scheme === scheme;\r\n    // If the chain is not provided, we accept any chain.\r\n    const isExpectedChain = !network || network == requirement.network;\r\n\r\n    return isExpectedScheme && isExpectedChain;\r\n  });\r\n\r\n  // Filter down to USDC requirements\r\n  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter(requirement => {\r\n    // If the address is a USDC address, we return it.\r\n    return requirement.asset === getUsdcAddressForChain(getNetworkId(requirement.network));\r\n  });\r\n\r\n  // Prioritize USDC requirements if available\r\n  if (usdcRequirements.length > 0) {\r\n    return usdcRequirements[0];\r\n  }\r\n\r\n  // If no USDC requirements are found, return the first broadly accepted requirement.\r\n  if (broadlyAcceptedPaymentRequirements.length > 0) {\r\n    return broadlyAcceptedPaymentRequirements[0];\r\n  }\r\n\r\n  // If no matching requirements are found, return the first requirement.\r\n  return paymentRequirements[0];\r\n}\r\n\r\n/**\r\n * Selector for payment requirements.\r\n * \r\n * @param paymentRequirements - The payment requirements to select from.\r\n * @param network - The network to check against. If not provided, the network will not be checked.\r\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\r\n * @returns The payment requirement that is the most appropriate for the user.\r\n */\r\nexport type PaymentRequirementsSelector = (paymentRequirements: PaymentRequirements[], network?: Network, scheme?: \"exact\") => PaymentRequirements;\r\n","import { selectPaymentRequirements } from \"../client\";\r\nimport { PaymentRequirements } from \"../types/verify\";\r\n\r\ninterface PaywallOptions {\r\n  amount: number;\r\n  paymentRequirements: PaymentRequirements[];\r\n  currentUrl: string;\r\n  testnet: boolean;\r\n}\r\n\r\n/**\r\n * Generates an HTML paywall page that allows users to pay for content access\r\n *\r\n * @param options - The options for generating the paywall\r\n * @param options.amount - The amount to be paid in USD\r\n * @param options.paymentRequirements - The payment requirements for the content\r\n * @param options.currentUrl - The URL of the content being accessed\r\n * @param options.testnet - Whether to use testnet or mainnet\r\n * @returns An HTML string containing the paywall page\r\n */\r\nexport function getPaywallHtml({\r\n  amount,\r\n  testnet,\r\n  paymentRequirements,\r\n  currentUrl,\r\n}: PaywallOptions): string {\r\n  const selectedPaymentRequirements = selectPaymentRequirements(\r\n    paymentRequirements,\r\n    testnet ? \"base-sepolia\" : \"base\",\r\n    \"exact\",\r\n  );\r\n  return `<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n<title>Payment Required - $${amount}</title>\r\n<link rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" />\r\n\r\n<style>\r\n  /* Reset */\r\n  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n  body { line-height: 1.5; -webkit-font-smoothing: antialiased; }\r\n  img, picture, video, canvas, svg { display: block; max-width: 100%; }\r\n  input, button, textarea, select { font: inherit; }\r\n  p, h1, h2, h3, h4, h5, h6 { overflow-wrap: break-word; }\r\n\r\n  /* Custom Styles */\r\n  body {\r\n    min-height: 100vh;\r\n    background-color: #f9fafb;\r\n    font-family: system-ui, -apple-system, sans-serif;\r\n  }\r\n\r\n  .container {\r\n    max-width: 32rem;\r\n    margin: 4rem auto;\r\n    padding: 1.5rem;\r\n    background-color: white;\r\n    border-radius: 0.75rem;\r\n    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\r\n  }\r\n\r\n  .header {\r\n    text-align: center;\r\n    margin-bottom: 2rem;\r\n  }\r\n\r\n  .title {\r\n    font-size: 1.5rem;\r\n    font-weight: 700;\r\n    color: #111827;\r\n    margin-bottom: 0.5rem;\r\n  }\r\n\r\n  .subtitle {\r\n    color: #4b5563;\r\n    margin-bottom: 1rem;\r\n  }\r\n\r\n  .instructions {\r\n    font-size: 0.9rem;\r\n    color: #4b5563;\r\n    font-style: italic;\r\n  }\r\n\r\n  .content {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 1rem;\r\n  }\r\n\r\n  .button {\r\n    width: 100%;\r\n    padding: 0.5rem 1rem;\r\n    border-radius: 0.5rem;\r\n    font-weight: 600;\r\n    border: none;\r\n    cursor: pointer;\r\n    transition: background-color 150ms;\r\n  }\r\n\r\n  .button:focus {\r\n    outline: none;\r\n    ring: 2px solid rgba(59, 130, 246, 0.5);\r\n  }\r\n\r\n  .button-blue {\r\n    background-color: #2563eb;\r\n    color: white;\r\n  }\r\n\r\n  .button-blue:hover {\r\n    background-color: #1d4ed8;\r\n  }\r\n\r\n  .button-green {\r\n    background-color: #059669;\r\n    color: white;\r\n  }\r\n\r\n  .button-green:hover {\r\n    background-color: #047857;\r\n  }\r\n\r\n  .payment-details {\r\n    padding: 1rem;\r\n    background-color: #f9fafb;\r\n    border-radius: 0.5rem;\r\n  }\r\n\r\n  .payment-row {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    font-size: 0.875rem;\r\n    margin-bottom: 0.5rem;\r\n  }\r\n\r\n  .payment-row:last-child {\r\n    margin-bottom: 0;\r\n  }\r\n\r\n  .payment-label {\r\n    color: #4b5563;\r\n  }\r\n\r\n  .payment-value {\r\n    font-weight: 500;\r\n  }\r\n\r\n  .hidden {\r\n    display: none;\r\n  }\r\n\r\n  .status {\r\n    text-align: center;\r\n    font-size: 0.875rem;\r\n  }\r\n</style>\r\n\r\n<!-- Inject server-side variables -->\r\n<script>\r\n  try {\r\n    // Initialize x402 namespace\r\n    window.x402 = {\r\n      paymentRequirements: ${JSON.stringify(selectedPaymentRequirements)},\r\n      isTestnet: ${testnet},\r\n      currentUrl: \"${currentUrl}\",\r\n      state: {\r\n        publicClient: null,\r\n        chain: null,\r\n        walletClient: null\r\n      },\r\n      config: {\r\n        chainConfig: {\r\n          \"84532\": {\r\n            usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\r\n            usdcName: \"USDC\",\r\n          },\r\n          \"8453\": {\r\n            usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\r\n            usdcName: \"USDC\",\r\n          }\r\n        },\r\n        networkToChainId: {\r\n          \"base-sepolia\": 84532,\r\n          \"base\": 8453\r\n        }\r\n      }\r\n    };\r\n    console.log('Payment requirements initialized:', window.x402.paymentRequirements);\r\n  } catch (error) {\r\n    console.error('Error initializing x402:', error.message);\r\n  };\r\n</script>\r\n\r\n<!-- x402 -->\r\n<script type=\"module\">\r\n  import {\r\n    createWalletClient,\r\n    createPublicClient,\r\n    http,\r\n    custom,\r\n    toHex,\r\n  } from 'https://esm.sh/viem'\r\n\r\n  import {\r\n    createConfig,\r\n    connect,\r\n    disconnect,\r\n    signMessage,\r\n    getBalance,\r\n  } from 'https://esm.sh/@wagmi/core'\r\n\r\n  import { injected, coinbaseWallet } from 'https://esm.sh/@wagmi/connectors'\r\n\r\n  import { base, baseSepolia } from 'https://esm.sh/viem/chains'\r\n\r\n  const authorizationTypes = {\r\n    EIP712Domain: [\r\n      { name: \"name\", type: \"string\" },\r\n      { name: \"version\", type: \"string\" },\r\n      { name: \"chainId\", type: \"uint256\" },\r\n      { name: \"verifyingContract\", type: \"address\" },\r\n    ],\r\n    TransferWithAuthorization: [\r\n      { name: \"from\", type: \"address\" },\r\n      { name: \"to\", type: \"address\" },\r\n      { name: \"value\", type: \"uint256\" },\r\n      { name: \"validAfter\", type: \"uint256\" },\r\n      { name: \"validBefore\", type: \"uint256\" },\r\n      { name: \"nonce\", type: \"bytes32\" },\r\n    ],\r\n  };\r\n\r\n  // USDC ABI for version function\r\n  const usdcABI = [{\r\n    \"inputs\": [],\r\n    \"name\": \"version\",\r\n    \"outputs\": [{\"internalType\": \"string\",\"name\": \"\",\"type\": \"string\"}],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  }];\r\n\r\n  window.x402.utils = {\r\n    createNonce: () => {\r\n      return toHex(crypto.getRandomValues(new Uint8Array(32)));\r\n    },\r\n    safeBase64Encode: (data) => {\r\n      if (typeof window !== \"undefined\") {\r\n        return window.btoa(data);\r\n      }\r\n      return Buffer.from(data).toString(\"base64\");\r\n    },\r\n    getUsdcAddressForChain: (chainId) => {\r\n      return window.x402.config.chainConfig[chainId.toString()].usdcAddress;\r\n    },\r\n    getNetworkId: (network) => {\r\n      const chainId = window.x402.config.networkToChainId[network];\r\n      if (!chainId) {\r\n        throw new Error('Unsupported network: ' + network);\r\n      }\r\n      return chainId;\r\n    },\r\n    getVersion: async (publicClient, usdcAddress) => {\r\n      const version = await publicClient.readContract({\r\n        address: usdcAddress,\r\n        abi: usdcABI,\r\n        functionName: \"version\"\r\n      });\r\n      return version;\r\n    },\r\n    encodePayment: (payment) => {\r\n      const safe = {\r\n        ...payment,\r\n        payload: {\r\n          ...payment.payload,\r\n          authorization: Object.fromEntries(\r\n            Object.entries(payment.payload.authorization).map(([key, value]) => [\r\n              key,\r\n              typeof value === \"bigint\" ? value.toString() : value,\r\n            ])\r\n          ),\r\n        },\r\n      };\r\n      return window.x402.utils.safeBase64Encode(JSON.stringify(safe));\r\n    },\r\n    createPaymentHeader: async (client, publicClient) => {\r\n      const payment = await window.x402.utils.createPayment(client, publicClient);\r\n      return window.x402.utils.encodePayment(payment);\r\n    },\r\n  }\r\n\r\n  window.x402.utils.signAuthorization = async (walletClient, authorizationParameters, paymentRequirements, publicClient) => {\r\n    const chainId = window.x402.utils.getNetworkId(paymentRequirements.network);\r\n    const name = paymentRequirements.extra?.name ?? window.x402.config.chainConfig[chainId].usdcName;\r\n    const erc20Address = paymentRequirements.asset;\r\n    const version = paymentRequirements.extra?.version ?? await window.x402.utils.getVersion(publicClient, erc20Address);\r\n    const { from, to, value, validAfter, validBefore, nonce } = authorizationParameters;\r\n    const data = {\r\n      account: walletClient.account,\r\n      types: authorizationTypes,\r\n      domain: {\r\n        name,\r\n        version,\r\n        chainId,\r\n        verifyingContract: erc20Address,\r\n      },\r\n      primaryType: \"TransferWithAuthorization\",\r\n      message: {\r\n        from,\r\n        to,\r\n        value,\r\n        validAfter,\r\n        validBefore,\r\n        nonce,\r\n      },\r\n    };\r\n\r\n    const signature = await walletClient.signTypedData(data);\r\n\r\n    return {\r\n      signature,\r\n    };\r\n  }\r\n\r\n  window.x402.utils.createPayment = async (client, publicClient) => {\r\n    if (!window.x402.paymentRequirements) {\r\n      throw new Error('Payment requirements not initialized');\r\n    }\r\n\r\n    const nonce = window.x402.utils.createNonce();\r\n    const version = await window.x402.utils.getVersion(publicClient, window.x402.utils.getUsdcAddressForChain(window.x402.utils.getNetworkId(window.x402.paymentRequirements.network)));\r\n    const from = client.account.address;\r\n\r\n    const validAfter = BigInt(\r\n      Math.floor(Date.now() / 1000) - 60 // 60 seconds before\r\n    );\r\n    const validBefore = BigInt(\r\n      Math.floor(Date.now() / 1000 + window.x402.paymentRequirements.maxTimeoutSeconds)\r\n    );\r\n\r\n    const { signature } = await window.x402.utils.signAuthorization(\r\n      client,\r\n      {\r\n        from,\r\n        to: window.x402.paymentRequirements.payTo,\r\n        value: window.x402.paymentRequirements.maxAmountRequired,\r\n        validAfter,\r\n        validBefore,\r\n        nonce,\r\n        version,\r\n      },\r\n      window.x402.paymentRequirements,\r\n      publicClient\r\n    );\r\n\r\n    return {\r\n      x402Version: 1,\r\n      scheme: window.x402.paymentRequirements.scheme,\r\n      network: window.x402.paymentRequirements.network,\r\n      payload: {\r\n        signature,\r\n        authorization: {\r\n          from,\r\n          to: window.x402.paymentRequirements.payTo,\r\n          value: window.x402.paymentRequirements.maxAmountRequired,\r\n          validAfter,\r\n          validBefore,\r\n          nonce,\r\n        },\r\n      },\r\n    };\r\n  }\r\n\r\n\r\n  async function initializeApp() {\r\n    const x402 = window.x402;\r\n    const wagmiConfig = createConfig({\r\n      chains: [base, baseSepolia],\r\n      connectors: [\r\n        coinbaseWallet({ appName: 'Create Wagmi' }),\r\n        injected(),\r\n      ],\r\n      transports: {\r\n        [base.id]: http(),\r\n        [baseSepolia.id]: http(),\r\n      },\r\n    });\r\n\r\n    // DOM Elements\r\n    const connectWalletBtn = document.getElementById('connect-wallet');\r\n    const paymentSection = document.getElementById('payment-section');\r\n    const payButton = document.getElementById('pay-button');\r\n    const statusDiv = document.getElementById('status');\r\n\r\n    if (!connectWalletBtn || !paymentSection || !payButton || !statusDiv) {\r\n      // console.error('Required DOM elements not found');\r\n      return;\r\n    }\r\n\r\n    let walletClient = null;\r\n    const chain = x402.isTestnet ? baseSepolia : base;\r\n\r\n    const publicClient = createPublicClient({\r\n      chain,\r\n      transport: custom(window.ethereum),\r\n    });\r\n\r\n    // Connect wallet handler\r\n    connectWalletBtn.addEventListener('click', async () => {\r\n      // If wallet is already connected, disconnect it\r\n      if (walletClient) {\r\n        try {\r\n          await disconnect(wagmiConfig);\r\n          walletClient = null;\r\n          connectWalletBtn.textContent = 'Connect Wallet';\r\n          paymentSection.classList.add('hidden');\r\n          statusDiv.textContent = 'Wallet disconnected';\r\n          return;\r\n        } catch (error) {\r\n          statusDiv.textContent = 'Failed to disconnect wallet';\r\n          return;\r\n        }\r\n      }\r\n\r\n      try {\r\n        statusDiv.textContent = 'Connecting wallet...';\r\n\r\n        const result = await connect(wagmiConfig, {\r\n          connector: injected(),\r\n          chainId: chain.id,\r\n        });\r\n        if (!result.accounts?.[0]) {\r\n          throw new Error('Please select an account in your wallet');\r\n        }\r\n        walletClient = createWalletClient({\r\n          account: result.accounts[0],\r\n          chain,\r\n          transport: custom(window.ethereum)\r\n        });\r\n\r\n        const address = result.accounts[0]\r\n\r\n        connectWalletBtn.textContent = \\`\\${address.slice(0, 6)}...\\${address.slice(-4)}\\`;\r\n        paymentSection.classList.remove('hidden');\r\n        statusDiv.textContent =\r\n          'Wallet connected! You can now proceed with payment.';\r\n      } catch (error) {\r\n        console.error('Connection error:', error);\r\n        statusDiv.textContent =\r\n          error instanceof Error ? error.message : 'Failed to connect wallet';\r\n        // Reset UI state\r\n        connectWalletBtn.textContent = 'Connect Wallet';\r\n        paymentSection.classList.add('hidden');\r\n      }\r\n    });\r\n\r\n  // Payment handler\r\n  payButton.addEventListener('click', async () => {\r\n    if (!walletClient) {\r\n      statusDiv.textContent = 'Please connect your wallet first';\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const usdcAddress = window.x402.config.chainConfig[chain.id].usdcAddress;\r\n      try {\r\n        statusDiv.textContent = 'Checking USDC balance...';\r\n        const balance = await publicClient.readContract({\r\n          address: usdcAddress,\r\n          abi: [{\r\n            inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\r\n            name: \"balanceOf\",\r\n            outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\r\n            stateMutability: \"view\",\r\n            type: \"function\"\r\n          }],\r\n          functionName: \"balanceOf\",\r\n          args: [walletClient.account.address]\r\n        });\r\n\r\n        if (balance === 0n) {\r\n          statusDiv.textContent = \\`Your USDC balance is 0. Please make sure you have USDC tokens on ${\r\n            testnet ? \"Base Sepolia\" : \"Base\"\r\n          }.\\`;\r\n          return;\r\n        }\r\n\r\n        statusDiv.textContent = 'Creating payment signature...';\r\n\r\n        const paymentHeader = await x402.utils.createPaymentHeader(walletClient, publicClient);\r\n\r\n        statusDiv.textContent = 'Requesting content with payment...';\r\n\r\n        const response = await fetch(x402.currentUrl, {\r\n          headers: {\r\n            'X-PAYMENT': paymentHeader,\r\n            'Access-Control-Expose-Headers': 'X-PAYMENT-RESPONSE',\r\n          },\r\n        });\r\n\r\n        if (response.ok) {\r\n          const contentType = response.headers.get('content-type');\r\n          if (contentType && contentType.includes('text/html')) {\r\n            document.documentElement.innerHTML = await response.text();\r\n          } else {\r\n            const blob = await response.blob();\r\n            const url = window.URL.createObjectURL(blob);\r\n            window.location.href = url;\r\n          }\r\n        } else {\r\n          throw new Error('Payment failed: ' + response.statusText);\r\n        }\r\n      } catch (error) {\r\n        statusDiv.textContent = error instanceof Error ? error.message : 'Failed to check USDC balance';\r\n      }\r\n    } catch (error) {\r\n      statusDiv.textContent = error instanceof Error ? error.message : 'Payment failed';\r\n    }\r\n  });\r\n}\r\n\r\nwindow.addEventListener('load', initializeApp);\r\n</script>\r\n</head>\r\n\r\n<body>\r\n  <div class=\"container\">\r\n    <div class=\"header\">\r\n      <h1 class=\"title\">Payment Required</h1>\r\n      <p class=\"subtitle\">${selectedPaymentRequirements.description}. To access this content, please pay $${amount} ${testnet ? \"Base Sepolia\" : \"Base\"} USDC.</p>\r\n      <p class=\"instructions\">Need Base Sepolia USDC? <a href=\"https://faucet.circle.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Get some here.</a></p>\r\n    </div>\r\n\r\n    <div class=\"content\">\r\n      <div id=\"connect-section\">\r\n        <button id=\"connect-wallet\" class=\"button button-blue\">\r\n            Connect Wallet\r\n        </button>\r\n      </div>\r\n\r\n      <div id=\"payment-section\" class=\"hidden\">\r\n        <div class=\"payment-details\">\r\n          <div class=\"payment-row\">\r\n            <span class=\"payment-label\">Amount:</span>\r\n            <span class=\"payment-value\">$${amount} USDC</span>\r\n          </div>\r\n          <div class=\"payment-row\">\r\n            <span class=\"payment-label\">Network:</span>\r\n            <span class=\"payment-value\">${testnet ? \"Base Sepolia\" : \"Base\"}</span>\r\n          </div>\r\n        </div>\r\n\r\n        <button id=\"pay-button\" class=\"button button-green\">\r\n            Pay Now\r\n        </button>\r\n      </div>\r\n      <div id=\"status\" class=\"status\"></div>\r\n    </div>\r\n  </div>\r\n</body>\r\n</html>`;\r\n}\r\n","/**\r\n * Encodes a string to base64 format\r\n *\r\n * @param data - The string to be encoded to base64\r\n * @returns The base64 encoded string\r\n */\r\nexport function safeBase64Encode(data: string): string {\r\n  return Buffer.from(data).toString(\"base64\");\r\n}\r\n\r\n/**\r\n * Decodes a base64 string back to its original format\r\n *\r\n * @param data - The base64 encoded string to be decoded\r\n * @returns The decoded string in UTF-8 format\r\n */\r\nexport function safeBase64Decode(data: string): string {\r\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\r\n}\r\n","import { generateJwt } from \"@coinbase/cdp-sdk/auth\";\r\nimport { version } from \"../version\";\r\n\r\nconst SDK_VERSION = \"1.1.1\";\r\n\r\n/**\r\n * Creates an authorization header for a request to the Coinbase API.\r\n *\r\n * @param apiKeyId - The api key ID\r\n * @param apiKeySecret - The api key secret\r\n * @param requestHost - The host for the request (e.g. 'https://x402.org/facilitator')\r\n * @param requestPath - The path for the request (e.g. '/verify')\r\n * @returns The authorization header string\r\n */\r\nexport async function createAuthHeader(\r\n  apiKeyId: string,\r\n  apiKeySecret: string,\r\n  requestHost: string,\r\n  requestPath: string,\r\n) {\r\n  const jwt = await generateJwt({\r\n    apiKeyId,\r\n    apiKeySecret,\r\n    requestMethod: \"POST\",\r\n    requestHost,\r\n    requestPath,\r\n  });\r\n  return `Bearer ${jwt}`;\r\n}\r\n\r\n/**\r\n * Creates a correlation header for a request to the Coinbase API.\r\n *\r\n * @returns The correlation header string\r\n */\r\nexport function createCorrelationHeader(): string {\r\n  const data: Record<string, string> = {\r\n    sdk_version: SDK_VERSION,\r\n    sdk_language: \"typescript\",\r\n    source: \"x402\",\r\n    source_version: version,\r\n  };\r\n  return Object.keys(data)\r\n    .map(key => `${key}=${encodeURIComponent(data[key])}`)\r\n    .join(\",\");\r\n}\r\n","export const version = \"0.3.3\";\r\n","import { Address, Hex } from \"viem\";\r\nimport {\r\n  moneySchema,\r\n  Network,\r\n  Price,\r\n  RouteConfig,\r\n  RoutePattern,\r\n  ERC20TokenAmount,\r\n  PaymentRequirements,\r\n  PaymentPayload,\r\n} from \"../types\";\r\nimport { RoutesConfig } from \"../types\";\r\nimport { safeBase64Decode } from \"./base64\";\r\nimport { getUsdcAddressForChain } from \"./evm\";\r\nimport { getNetworkId } from \"./network\";\r\n\r\n/**\r\n * Computes the route patterns for the given routes config\r\n *\r\n * @param routes - The routes config to compute the patterns for\r\n * @returns The route patterns\r\n */\r\nexport function computeRoutePatterns(routes: RoutesConfig): RoutePattern[] {\r\n  const normalizedRoutes = Object.fromEntries(\r\n    Object.entries(routes).map(([pattern, value]) => [\r\n      pattern,\r\n      typeof value === \"string\" || typeof value === \"number\"\r\n        ? ({ price: value, network: \"base-sepolia\" } as RouteConfig)\r\n        : (value as RouteConfig),\r\n    ]),\r\n  );\r\n\r\n  return Object.entries(normalizedRoutes).map(([pattern, routeConfig]) => {\r\n    // Split pattern into verb and path, defaulting to \"*\" for verb if not specified\r\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\r\n    if (!path) {\r\n      throw new Error(`Invalid route pattern: ${pattern}`);\r\n    }\r\n    return {\r\n      verb: verb.toUpperCase(),\r\n      pattern: new RegExp(\r\n        `^${path\r\n          .replace(/\\*/g, \".*?\") // Make wildcard non-greedy and optional\r\n          .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\")\r\n          .replace(/\\//g, \"\\\\/\")}$`,\r\n        \"i\",\r\n      ),\r\n      config: routeConfig,\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Finds the matching route pattern for the given path and method\r\n *\r\n * @param routePatterns - The route patterns to search through\r\n * @param path - The path to match against\r\n * @param method - The HTTP method to match against\r\n * @returns The matching route pattern or undefined if no match is found\r\n */\r\nexport function findMatchingRoute(\r\n  routePatterns: RoutePattern[],\r\n  path: string,\r\n  method: string,\r\n): RoutePattern | undefined {\r\n  // Find matching route pattern\r\n  const matchingRoutes = routePatterns.filter(({ pattern, verb }) => {\r\n    const matchesPath = pattern.test(path);\r\n    const matchesVerb = verb === \"*\" || verb === method.toUpperCase();\r\n    return matchesPath && matchesVerb;\r\n  });\r\n\r\n  if (matchingRoutes.length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  // Use the most specific route (longest path pattern)\r\n  const matchingRoute = matchingRoutes.reduce((a, b) =>\r\n    b.pattern.source.length > a.pattern.source.length ? b : a,\r\n  );\r\n\r\n  return matchingRoute;\r\n}\r\n\r\n/**\r\n * Gets the default asset (USDC) for the given network\r\n *\r\n * @param network - The network to get the default asset for\r\n * @returns The default asset\r\n */\r\nexport function getDefaultAsset(network: Network) {\r\n  return {\r\n    address: getUsdcAddressForChain(getNetworkId(network)),\r\n    decimals: 6,\r\n    eip712: {\r\n      name: network === \"base\" ? \"USD Coin\" : \"USDC\",\r\n      version: \"2\",\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Parses the amount from the given price\r\n *\r\n * @param price - The price to parse\r\n * @param network - The network to get the default asset for\r\n * @returns The parsed amount or an error message\r\n */\r\nexport function processPriceToAtomicAmount(\r\n  price: Price,\r\n  network: Network,\r\n): { maxAmountRequired: string; asset: ERC20TokenAmount[\"asset\"] } | { error: string } {\r\n  // Handle USDC amount (string) or token amount (ERC20TokenAmount)\r\n  let maxAmountRequired: string;\r\n  let asset: ERC20TokenAmount[\"asset\"];\r\n\r\n  if (typeof price === \"string\" || typeof price === \"number\") {\r\n    // USDC amount in dollars\r\n    const parsedAmount = moneySchema.safeParse(price);\r\n    if (!parsedAmount.success) {\r\n      return {\r\n        error: `Invalid price (price: ${price}). Must be in the form \"$3.10\", 0.10, \"0.001\", ${parsedAmount.error}`,\r\n      };\r\n    }\r\n    const parsedUsdAmount = parsedAmount.data;\r\n    asset = getDefaultAsset(network);\r\n    maxAmountRequired = (parsedUsdAmount * 10 ** asset.decimals).toString();\r\n  } else {\r\n    // Token amount in atomic units\r\n    maxAmountRequired = price.amount;\r\n    asset = price.asset;\r\n  }\r\n\r\n  return {\r\n    maxAmountRequired,\r\n    asset,\r\n  };\r\n}\r\n\r\n/**\r\n * Finds the matching payment requirements for the given payment\r\n *\r\n * @param paymentRequirements - The payment requirements to search through\r\n * @param payment - The payment to match against\r\n * @returns The matching payment requirements or undefined if no match is found\r\n */\r\nexport function findMatchingPaymentRequirements(\r\n  paymentRequirements: PaymentRequirements[],\r\n  payment: PaymentPayload,\r\n) {\r\n  return paymentRequirements.find(\r\n    value => value.scheme === payment.scheme && value.network === payment.network,\r\n  );\r\n}\r\n\r\n/**\r\n * Decodes the X-PAYMENT-RESPONSE header\r\n *\r\n * @param header - The X-PAYMENT-RESPONSE header to decode\r\n * @returns The decoded payment response\r\n */\r\nexport function decodeXPaymentResponse(header: string) {\r\n  const decoded = safeBase64Decode(header);\r\n  return JSON.parse(decoded) as {\r\n    success: boolean;\r\n    transaction: Hex;\r\n    network: Network;\r\n    payer: Address;\r\n  };\r\n}\r\n"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAiIN,KAAK,UAAU,2BAA2B,CAAC;AAAA,mBACrD,OAAO;AAAA,qBACL,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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","names":["import_viem","import_zod","import_zod","import_zod"]}